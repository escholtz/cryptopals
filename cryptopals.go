package cryptopals

import (
	"encoding/base64"
	"encoding/hex"
	"errors"
)

func hexToBase64(x string) (string, error) {
	buf, err := hex.DecodeString(x)
	if err != nil {
		return "", err
	}
	return base64.RawStdEncoding.EncodeToString(buf), nil
}

func xor(a, b []byte) ([]byte, error) {
	if len(a) != len(b) {
		return nil, errors.New("lengths must be equal")
	}
	out := make([]byte, len(a))
	for i := range a {
		out[i] = a[i] ^ b[i]
	}
	return out, nil
}

// Calculated from https://wortschatz.uni-leipzig.de/en/download/english
// english wikipedia 2016 1M
var byteFreq = [256]float64{
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.155531, // " "
	0.000027, // "!"
	0.001943, // "\""
	0.000000, // "#"
	0.000068, // "$"
	0.000144, // "%"
	0.000039, // "&"
	0.001343, // "'"
	0.001265, // "("
	0.001242, // ")"
	0.000068, // "*"
	0.000017, // "+"
	0.008684, // ","
	0.001721, // "-"
	0.009053, // "."
	0.000149, // "/"
	0.002415, // "0"
	0.002816, // "1"
	0.001526, // "2"
	0.000813, // "3"
	0.000765, // "4"
	0.000849, // "5"
	0.000739, // "6"
	0.000724, // "7"
	0.000910, // "8"
	0.001643, // "9"
	0.000449, // ":"
	0.000303, // ";"
	0.000002, // "<"
	0.000000, // "="
	0.000003, // ">"
	0.000035, // "?"
	0.000001, // "@"
	0.002554, // "A"
	0.001447, // "B"
	0.002060, // "C"
	0.001066, // "D"
	0.001007, // "E"
	0.001051, // "F"
	0.000912, // "G"
	0.001268, // "H"
	0.002022, // "I"
	0.000619, // "J"
	0.000445, // "K"
	0.000935, // "L"
	0.001606, // "M"
	0.000891, // "N"
	0.000744, // "O"
	0.001398, // "P"
	0.000083, // "Q"
	0.001018, // "R"
	0.002412, // "S"
	0.003389, // "T"
	0.000570, // "U"
	0.000399, // "V"
	0.000898, // "W"
	0.000090, // "X"
	0.000176, // "Y"
	0.000092, // "Z"
	0.000000, // "["
	0.000000, // "\\"
	0.000000, // "]"
	0.000000, // "^"
	0.000000, // "_"
	0.000001, // "`"
	0.064907, // "a"
	0.010706, // "b"
	0.026175, // "c"
	0.029838, // "d"
	0.097441, // "e"
	0.016860, // "f"
	0.014511, // "g"
	0.035720, // "h"
	0.059227, // "i"
	0.000722, // "j"
	0.004083, // "k"
	0.032618, // "l"
	0.019376, // "m"
	0.057540, // "n"
	0.058281, // "o"
	0.016234, // "p"
	0.000832, // "q"
	0.051717, // "r"
	0.051949, // "s"
	0.068446, // "t"
	0.020917, // "u"
	0.008347, // "v"
	0.011639, // "w"
	0.001778, // "x"
	0.012310, // "y"
	0.000887, // "z"
	0.000000, // "{"
	0.000000, // "|"
	0.000000, // "}"
	0.000003, // "~"
	0.000000,
	0.000453,
	0.000023,
	0.000015,
	0.000008,
	0.000008,
	0.000005,
	0.000011,
	0.000007,
	0.000014,
	0.000010,
	0.000002,
	0.000003,
	0.000005,
	0.000014,
	0.000002,
	0.000003,
	0.000004,
	0.000004,
	0.000013,
	0.000249,
	0.000092,
	0.000003,
	0.000003,
	0.000007,
	0.000009,
	0.000062,
	0.000002,
	0.000004,
	0.000024,
	0.000024,
	0.000003,
	0.000005,
	0.000007,
	0.000027,
	0.000005,
	0.000015,
	0.000018,
	0.000007,
	0.000009,
	0.000010,
	0.000012,
	0.000066,
	0.000005,
	0.000013,
	0.000006,
	0.000020,
	0.000004,
	0.000005,
	0.000026,
	0.000015,
	0.000010,
	0.000019,
	0.000006,
	0.000007,
	0.000021,
	0.000006,
	0.000013,
	0.000008,
	0.000009,
	0.000008,
	0.000023,
	0.000009,
	0.000006,
	0.000007,
	0.000000,
	0.000000,
	0.000039,
	0.000238,
	0.000031,
	0.000032,
	0.000001,
	0.000001,
	0.000002,
	0.000002,
	0.000002,
	0.000001,
	0.000001,
	0.000000,
	0.000044,
	0.000020,
	0.000018,
	0.000007,
	0.000000,
	0.000000,
	0.000000,
	0.000001,
	0.000001,
	0.000008,
	0.000004,
	0.000003,
	0.000000,
	0.000000,
	0.000001,
	0.000000,
	0.000000,
	0.000000,
	0.000013,
	0.000012,
	0.000469,
	0.000006,
	0.000002,
	0.000008,
	0.000005,
	0.000004,
	0.000003,
	0.000003,
	0.000000,
	0.000001,
	0.000001,
	0.000000,
	0.000000,
	0.000001,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
	0.000000,
}

func byteCount(x []byte) [256]uint64 {
	out := [256]uint64{}
	for _, b := range x {
		out[b]++
	}
	return out
}

func sum256(counts [256]uint64) uint64 {
	var sum uint64
	for _, n := range counts {
		sum += n
	}
	return sum
}

func byteChiSquared(counts [256]uint64) float64 {
	sum := float64(sum256(counts))
	out := 0.0
	for i, f := range byteFreq {
		// avoid divide by zero
		if f < 0.000001 {
			continue
		}
		actual := float64(counts[i]) / sum
		expected := sum * f
		diff := actual - expected
		out += ((diff * diff) / expected)
	}
	return out
}

func bestSingleByteXor(in []byte) (byte, float64, string) {
	var best byte
	bestScore := 1e9
	msg := ""
	out := make([]byte, len(in))
	for i := byte(0); i < byte(255); i++ {
		for j := range in {
			out[j] = in[j] ^ i
		}
		// if !utf8.Valid(out) {
		// 	continue
		// }
		//out = bytes.ToLower(out)
		e := byteChiSquared(byteCount(out))
		if e < bestScore {
			bestScore = e
			best = i
			msg = string(out)
		}
	}
	return best, bestScore, msg
}

func repeatingKeyXor(key []byte, msg []byte) []byte {
	out := make([]byte, len(msg))
	n := len(key)
	for i, b := range msg {
		out[i] = b ^ key[i%n]
	}
	return out
}
